# Approaching SQL Interview Question
## Make sure to consistently verbalize and not rush
1. understand question
    - after getting problem -> understand and clarify what is req to be done

2. id relevant info
    - determine what info is actually required to perform query relevant to problem
    - identify what is actually needed to directly answer SQL interview question at hand

3. break down problem
    - often sql problems involve a multi-part solution consisting of several joins, unions, subqueries and CTEs
    - map out smaller building blocks required for final solution (complex problems -> smaller sub-problems)

4. consider edge cases
    - don't forget edge cases such as if a value is null or if there is a tie in results set by thinking about it before writing sql query
        * often times there will be tricky test cases that catch handling of all edge cases

5. write queries for sub problems
    - write small subqs that answer sub-probs
    - test solutions incrementally and combine sub-problem results

6. test final query
    - run sql query and validate that output matches expected output
    - Can be a difference between expected results, what is produced

# Popular Questions
## What is a self join and when is it to be used?
- A self join is a type of sql join where table is joined on self (create relationship between rows in same table)
    * [self joins](sql-bolt/joins.md)
    - uses inner join keyword
    ```sql
    -- if employees, managers table
    select e.employeeName as employee_name, m.employeeName as manager_name
    from employees e
    inner join employees m
        on (e.ManagerId=m.EmployeeID)
    ```
## What is an anti-join and when is it to be used?
- type of join used to find rows in one table that don't have corresponding rows in another table
    * opposite of inner join
    - example: id records missing, don't meet criteria, find customers that have not purchased performed anti join between customers and orders table
    ```sql
    select c.customers_name, o.purchase_name, o.purchase_date
    from customers c
    right join orders o
        on (c.purchase_id=o.id)
    where c.purchase_id is null
    ```
## What are performance considerations of SQL join queries?
- indexing: properly index cols used in join conditions to improve query performance
- query plan: understand query plan execution generated by db optimizer w/ tools like 'EXPLAIN'
- data distribution: uneven data distributions can impact join performance (data sharding, partitions)

## How to optimize a slow join query?
- indexing: create indexes on cols used in join conditions
- cleanup: ensure data quality, remove unnecessary
- limit result set: retrieve only cols u need by avoiding `select *`
- caching, analyze execution plan

## Does a join always have to be on two rows sharing the same value (non-equi joins)?
- can perform non-equi joins using operators like '<,>, <=, >=' in order to match rows based on conditions that are not just strict equality
    * using where `where orders.total_amount>thresholds.threshold_amount`
    - example
    ```sql
    SELECT e.employee_name, p.project_name
    FROM employees e
    INNER JOIN projects p
        ON (e.hire_date BETWEEN p.start_date AND p.end_date);
    ```
